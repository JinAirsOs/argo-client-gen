/*
 * Argo Workflows API
 * Argo Workflows is an open source container-native workflow engine for orchestrating parallel jobs on Kubernetes. For more information, please see https://argoproj.github.io/argo-workflows/
 *
 * The version of the OpenAPI document: VERSION
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.argoproj.workflow.v1alpha;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.argoproj.workflow.v1alpha.ArtGCStatus;
import io.argoproj.workflow.v1alpha.ArtifactRepositoryRefStatus;
import io.argoproj.workflow.v1alpha.Condition;
import io.argoproj.workflow.v1alpha.NodeStatus;
import io.argoproj.workflow.v1alpha.Outputs;
import io.argoproj.workflow.v1alpha.SynchronizationStatus;
import io.argoproj.workflow.v1alpha.Template;
import io.argoproj.workflow.v1alpha.WorkflowSpec;
import io.kubernetes.client.models.V1Volume;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.joda.time.DateTime;

/**
 * WorkflowStatus contains overall status information about a workflow
 */
@ApiModel(description = "WorkflowStatus contains overall status information about a workflow")

public class WorkflowStatus {
  public static final String SERIALIZED_NAME_ARTIFACT_G_C_STATUS = "artifactGCStatus";
  @SerializedName(SERIALIZED_NAME_ARTIFACT_G_C_STATUS)
  private ArtGCStatus artifactGCStatus;

  public static final String SERIALIZED_NAME_ARTIFACT_REPOSITORY_REF = "artifactRepositoryRef";
  @SerializedName(SERIALIZED_NAME_ARTIFACT_REPOSITORY_REF)
  private ArtifactRepositoryRefStatus artifactRepositoryRef;

  public static final String SERIALIZED_NAME_COMPRESSED_NODES = "compressedNodes";
  @SerializedName(SERIALIZED_NAME_COMPRESSED_NODES)
  private String compressedNodes;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<Condition> conditions = null;

  public static final String SERIALIZED_NAME_ESTIMATED_DURATION = "estimatedDuration";
  @SerializedName(SERIALIZED_NAME_ESTIMATED_DURATION)
  private Integer estimatedDuration;

  public static final String SERIALIZED_NAME_FINISHED_AT = "finishedAt";
  @SerializedName(SERIALIZED_NAME_FINISHED_AT)
  private DateTime finishedAt;

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  private String message;

  public static final String SERIALIZED_NAME_NODES = "nodes";
  @SerializedName(SERIALIZED_NAME_NODES)
  private Map<String, NodeStatus> nodes = null;

  public static final String SERIALIZED_NAME_OFFLOAD_NODE_STATUS_VERSION = "offloadNodeStatusVersion";
  @SerializedName(SERIALIZED_NAME_OFFLOAD_NODE_STATUS_VERSION)
  private String offloadNodeStatusVersion;

  public static final String SERIALIZED_NAME_OUTPUTS = "outputs";
  @SerializedName(SERIALIZED_NAME_OUTPUTS)
  private Outputs outputs;

  public static final String SERIALIZED_NAME_PERSISTENT_VOLUME_CLAIMS = "persistentVolumeClaims";
  @SerializedName(SERIALIZED_NAME_PERSISTENT_VOLUME_CLAIMS)
  private List<V1Volume> persistentVolumeClaims = null;

  public static final String SERIALIZED_NAME_PHASE = "phase";
  @SerializedName(SERIALIZED_NAME_PHASE)
  private String phase;

  public static final String SERIALIZED_NAME_PROGRESS = "progress";
  @SerializedName(SERIALIZED_NAME_PROGRESS)
  private String progress;

  public static final String SERIALIZED_NAME_RESOURCES_DURATION = "resourcesDuration";
  @SerializedName(SERIALIZED_NAME_RESOURCES_DURATION)
  private Map<String, Long> resourcesDuration = null;

  public static final String SERIALIZED_NAME_STARTED_AT = "startedAt";
  @SerializedName(SERIALIZED_NAME_STARTED_AT)
  private DateTime startedAt;

  public static final String SERIALIZED_NAME_STORED_TEMPLATES = "storedTemplates";
  @SerializedName(SERIALIZED_NAME_STORED_TEMPLATES)
  private Map<String, Template> storedTemplates = null;

  public static final String SERIALIZED_NAME_STORED_WORKFLOW_TEMPLATE_SPEC = "storedWorkflowTemplateSpec";
  @SerializedName(SERIALIZED_NAME_STORED_WORKFLOW_TEMPLATE_SPEC)
  private WorkflowSpec storedWorkflowTemplateSpec;

  public static final String SERIALIZED_NAME_SYNCHRONIZATION = "synchronization";
  @SerializedName(SERIALIZED_NAME_SYNCHRONIZATION)
  private SynchronizationStatus synchronization;


  public WorkflowStatus artifactGCStatus(ArtGCStatus artifactGCStatus) {
    
    this.artifactGCStatus = artifactGCStatus;
    return this;
  }

   /**
   * Get artifactGCStatus
   * @return artifactGCStatus
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ArtGCStatus getArtifactGCStatus() {
    return artifactGCStatus;
  }


  public void setArtifactGCStatus(ArtGCStatus artifactGCStatus) {
    this.artifactGCStatus = artifactGCStatus;
  }


  public WorkflowStatus artifactRepositoryRef(ArtifactRepositoryRefStatus artifactRepositoryRef) {
    
    this.artifactRepositoryRef = artifactRepositoryRef;
    return this;
  }

   /**
   * Get artifactRepositoryRef
   * @return artifactRepositoryRef
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ArtifactRepositoryRefStatus getArtifactRepositoryRef() {
    return artifactRepositoryRef;
  }


  public void setArtifactRepositoryRef(ArtifactRepositoryRefStatus artifactRepositoryRef) {
    this.artifactRepositoryRef = artifactRepositoryRef;
  }


  public WorkflowStatus compressedNodes(String compressedNodes) {
    
    this.compressedNodes = compressedNodes;
    return this;
  }

   /**
   * Compressed and base64 decoded Nodes map
   * @return compressedNodes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Compressed and base64 decoded Nodes map")

  public String getCompressedNodes() {
    return compressedNodes;
  }


  public void setCompressedNodes(String compressedNodes) {
    this.compressedNodes = compressedNodes;
  }


  public WorkflowStatus conditions(List<Condition> conditions) {
    
    this.conditions = conditions;
    return this;
  }

  public WorkflowStatus addConditionsItem(Condition conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<Condition>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions is a list of conditions the Workflow may have
   * @return conditions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Conditions is a list of conditions the Workflow may have")

  public List<Condition> getConditions() {
    return conditions;
  }


  public void setConditions(List<Condition> conditions) {
    this.conditions = conditions;
  }


  public WorkflowStatus estimatedDuration(Integer estimatedDuration) {
    
    this.estimatedDuration = estimatedDuration;
    return this;
  }

   /**
   * EstimatedDuration in seconds.
   * @return estimatedDuration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "EstimatedDuration in seconds.")

  public Integer getEstimatedDuration() {
    return estimatedDuration;
  }


  public void setEstimatedDuration(Integer estimatedDuration) {
    this.estimatedDuration = estimatedDuration;
  }


  public WorkflowStatus finishedAt(DateTime finishedAt) {
    
    this.finishedAt = finishedAt;
    return this;
  }

   /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   * @return finishedAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.")

  public DateTime getFinishedAt() {
    return finishedAt;
  }


  public void setFinishedAt(DateTime finishedAt) {
    this.finishedAt = finishedAt;
  }


  public WorkflowStatus message(String message) {
    
    this.message = message;
    return this;
  }

   /**
   * A human readable message indicating details about why the workflow is in this condition.
   * @return message
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A human readable message indicating details about why the workflow is in this condition.")

  public String getMessage() {
    return message;
  }


  public void setMessage(String message) {
    this.message = message;
  }


  public WorkflowStatus nodes(Map<String, NodeStatus> nodes) {
    
    this.nodes = nodes;
    return this;
  }

  public WorkflowStatus putNodesItem(String key, NodeStatus nodesItem) {
    if (this.nodes == null) {
      this.nodes = new HashMap<String, NodeStatus>();
    }
    this.nodes.put(key, nodesItem);
    return this;
  }

   /**
   * Nodes is a mapping between a node ID and the node&#39;s status.
   * @return nodes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Nodes is a mapping between a node ID and the node's status.")

  public Map<String, NodeStatus> getNodes() {
    return nodes;
  }


  public void setNodes(Map<String, NodeStatus> nodes) {
    this.nodes = nodes;
  }


  public WorkflowStatus offloadNodeStatusVersion(String offloadNodeStatusVersion) {
    
    this.offloadNodeStatusVersion = offloadNodeStatusVersion;
    return this;
  }

   /**
   * Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty. This will actually be populated with a hash of the offloaded data.
   * @return offloadNodeStatusVersion
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty. This will actually be populated with a hash of the offloaded data.")

  public String getOffloadNodeStatusVersion() {
    return offloadNodeStatusVersion;
  }


  public void setOffloadNodeStatusVersion(String offloadNodeStatusVersion) {
    this.offloadNodeStatusVersion = offloadNodeStatusVersion;
  }


  public WorkflowStatus outputs(Outputs outputs) {
    
    this.outputs = outputs;
    return this;
  }

   /**
   * Get outputs
   * @return outputs
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Outputs getOutputs() {
    return outputs;
  }


  public void setOutputs(Outputs outputs) {
    this.outputs = outputs;
  }


  public WorkflowStatus persistentVolumeClaims(List<V1Volume> persistentVolumeClaims) {
    
    this.persistentVolumeClaims = persistentVolumeClaims;
    return this;
  }

  public WorkflowStatus addPersistentVolumeClaimsItem(V1Volume persistentVolumeClaimsItem) {
    if (this.persistentVolumeClaims == null) {
      this.persistentVolumeClaims = new ArrayList<V1Volume>();
    }
    this.persistentVolumeClaims.add(persistentVolumeClaimsItem);
    return this;
  }

   /**
   * PersistentVolumeClaims tracks all PVCs that were created as part of the io.argoproj.workflow.v1alpha1. The contents of this list are drained at the end of the workflow.
   * @return persistentVolumeClaims
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "PersistentVolumeClaims tracks all PVCs that were created as part of the io.argoproj.workflow.v1alpha1. The contents of this list are drained at the end of the workflow.")

  public List<V1Volume> getPersistentVolumeClaims() {
    return persistentVolumeClaims;
  }


  public void setPersistentVolumeClaims(List<V1Volume> persistentVolumeClaims) {
    this.persistentVolumeClaims = persistentVolumeClaims;
  }


  public WorkflowStatus phase(String phase) {
    
    this.phase = phase;
    return this;
  }

   /**
   * Phase a simple, high-level summary of where the workflow is in its lifecycle.
   * @return phase
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Phase a simple, high-level summary of where the workflow is in its lifecycle.")

  public String getPhase() {
    return phase;
  }


  public void setPhase(String phase) {
    this.phase = phase;
  }


  public WorkflowStatus progress(String progress) {
    
    this.progress = progress;
    return this;
  }

   /**
   * Progress to completion
   * @return progress
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Progress to completion")

  public String getProgress() {
    return progress;
  }


  public void setProgress(String progress) {
    this.progress = progress;
  }


  public WorkflowStatus resourcesDuration(Map<String, Long> resourcesDuration) {
    
    this.resourcesDuration = resourcesDuration;
    return this;
  }

  public WorkflowStatus putResourcesDurationItem(String key, Long resourcesDurationItem) {
    if (this.resourcesDuration == null) {
      this.resourcesDuration = new HashMap<String, Long>();
    }
    this.resourcesDuration.put(key, resourcesDurationItem);
    return this;
  }

   /**
   * ResourcesDuration is the total for the workflow
   * @return resourcesDuration
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "ResourcesDuration is the total for the workflow")

  public Map<String, Long> getResourcesDuration() {
    return resourcesDuration;
  }


  public void setResourcesDuration(Map<String, Long> resourcesDuration) {
    this.resourcesDuration = resourcesDuration;
  }


  public WorkflowStatus startedAt(DateTime startedAt) {
    
    this.startedAt = startedAt;
    return this;
  }

   /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   * @return startedAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.")

  public DateTime getStartedAt() {
    return startedAt;
  }


  public void setStartedAt(DateTime startedAt) {
    this.startedAt = startedAt;
  }


  public WorkflowStatus storedTemplates(Map<String, Template> storedTemplates) {
    
    this.storedTemplates = storedTemplates;
    return this;
  }

  public WorkflowStatus putStoredTemplatesItem(String key, Template storedTemplatesItem) {
    if (this.storedTemplates == null) {
      this.storedTemplates = new HashMap<String, Template>();
    }
    this.storedTemplates.put(key, storedTemplatesItem);
    return this;
  }

   /**
   * StoredTemplates is a mapping between a template ref and the node&#39;s status.
   * @return storedTemplates
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "StoredTemplates is a mapping between a template ref and the node's status.")

  public Map<String, Template> getStoredTemplates() {
    return storedTemplates;
  }


  public void setStoredTemplates(Map<String, Template> storedTemplates) {
    this.storedTemplates = storedTemplates;
  }


  public WorkflowStatus storedWorkflowTemplateSpec(WorkflowSpec storedWorkflowTemplateSpec) {
    
    this.storedWorkflowTemplateSpec = storedWorkflowTemplateSpec;
    return this;
  }

   /**
   * Get storedWorkflowTemplateSpec
   * @return storedWorkflowTemplateSpec
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public WorkflowSpec getStoredWorkflowTemplateSpec() {
    return storedWorkflowTemplateSpec;
  }


  public void setStoredWorkflowTemplateSpec(WorkflowSpec storedWorkflowTemplateSpec) {
    this.storedWorkflowTemplateSpec = storedWorkflowTemplateSpec;
  }


  public WorkflowStatus synchronization(SynchronizationStatus synchronization) {
    
    this.synchronization = synchronization;
    return this;
  }

   /**
   * Get synchronization
   * @return synchronization
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public SynchronizationStatus getSynchronization() {
    return synchronization;
  }


  public void setSynchronization(SynchronizationStatus synchronization) {
    this.synchronization = synchronization;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WorkflowStatus ioArgoprojWorkflowV1alpha1WorkflowStatus = (WorkflowStatus) o;
    return Objects.equals(this.artifactGCStatus, ioArgoprojWorkflowV1alpha1WorkflowStatus.artifactGCStatus) &&
        Objects.equals(this.artifactRepositoryRef, ioArgoprojWorkflowV1alpha1WorkflowStatus.artifactRepositoryRef) &&
        Objects.equals(this.compressedNodes, ioArgoprojWorkflowV1alpha1WorkflowStatus.compressedNodes) &&
        Objects.equals(this.conditions, ioArgoprojWorkflowV1alpha1WorkflowStatus.conditions) &&
        Objects.equals(this.estimatedDuration, ioArgoprojWorkflowV1alpha1WorkflowStatus.estimatedDuration) &&
        Objects.equals(this.finishedAt, ioArgoprojWorkflowV1alpha1WorkflowStatus.finishedAt) &&
        Objects.equals(this.message, ioArgoprojWorkflowV1alpha1WorkflowStatus.message) &&
        Objects.equals(this.nodes, ioArgoprojWorkflowV1alpha1WorkflowStatus.nodes) &&
        Objects.equals(this.offloadNodeStatusVersion, ioArgoprojWorkflowV1alpha1WorkflowStatus.offloadNodeStatusVersion) &&
        Objects.equals(this.outputs, ioArgoprojWorkflowV1alpha1WorkflowStatus.outputs) &&
        Objects.equals(this.persistentVolumeClaims, ioArgoprojWorkflowV1alpha1WorkflowStatus.persistentVolumeClaims) &&
        Objects.equals(this.phase, ioArgoprojWorkflowV1alpha1WorkflowStatus.phase) &&
        Objects.equals(this.progress, ioArgoprojWorkflowV1alpha1WorkflowStatus.progress) &&
        Objects.equals(this.resourcesDuration, ioArgoprojWorkflowV1alpha1WorkflowStatus.resourcesDuration) &&
        Objects.equals(this.startedAt, ioArgoprojWorkflowV1alpha1WorkflowStatus.startedAt) &&
        Objects.equals(this.storedTemplates, ioArgoprojWorkflowV1alpha1WorkflowStatus.storedTemplates) &&
        Objects.equals(this.storedWorkflowTemplateSpec, ioArgoprojWorkflowV1alpha1WorkflowStatus.storedWorkflowTemplateSpec) &&
        Objects.equals(this.synchronization, ioArgoprojWorkflowV1alpha1WorkflowStatus.synchronization);
  }

  @Override
  public int hashCode() {
    return Objects.hash(artifactGCStatus, artifactRepositoryRef, compressedNodes, conditions, estimatedDuration, finishedAt, message, nodes, offloadNodeStatusVersion, outputs, persistentVolumeClaims, phase, progress, resourcesDuration, startedAt, storedTemplates, storedWorkflowTemplateSpec, synchronization);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WorkflowStatus {\n");
    sb.append("    artifactGCStatus: ").append(toIndentedString(artifactGCStatus)).append("\n");
    sb.append("    artifactRepositoryRef: ").append(toIndentedString(artifactRepositoryRef)).append("\n");
    sb.append("    compressedNodes: ").append(toIndentedString(compressedNodes)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    estimatedDuration: ").append(toIndentedString(estimatedDuration)).append("\n");
    sb.append("    finishedAt: ").append(toIndentedString(finishedAt)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    nodes: ").append(toIndentedString(nodes)).append("\n");
    sb.append("    offloadNodeStatusVersion: ").append(toIndentedString(offloadNodeStatusVersion)).append("\n");
    sb.append("    outputs: ").append(toIndentedString(outputs)).append("\n");
    sb.append("    persistentVolumeClaims: ").append(toIndentedString(persistentVolumeClaims)).append("\n");
    sb.append("    phase: ").append(toIndentedString(phase)).append("\n");
    sb.append("    progress: ").append(toIndentedString(progress)).append("\n");
    sb.append("    resourcesDuration: ").append(toIndentedString(resourcesDuration)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    storedTemplates: ").append(toIndentedString(storedTemplates)).append("\n");
    sb.append("    storedWorkflowTemplateSpec: ").append(toIndentedString(storedWorkflowTemplateSpec)).append("\n");
    sb.append("    synchronization: ").append(toIndentedString(synchronization)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

